// Package postgres GENERATED FROM AI, PLEASE DO NOT EDIT THIS FILE.
package postgres

import (
	"context"
	"fmt"
	"github.com/imiskolee/anycdc/pkg/core"
	"github.com/jackc/pglogrepl"
	"github.com/jackc/pgx/v5/pgxpool"
	"sort"
	"strings"
)

type replication struct {
	conn            *pgxpool.Pool
	publicationName string
	slotName        string
	tables          []string
	logger          *core.FileLogger
}

func (r *replication) getLatestPosition() (pglogrepl.LSN, error) {
	var currentLSN pglogrepl.LSN
	query := `SELECT restart_lsn FROM pg_replication_slots WHERE slot_name = $1`
	row := r.conn.QueryRow(context.Background(), query, r.slotName)
	err := row.Scan(&currentLSN)
	if err != nil {
		r.logger.Error("Failed to get latest LSN: %s", err)
	}
	return currentLSN, err
}

func (r *replication) getTableDiff(currentTables, desiredTables []string) (toAdd, toRemove []string) {
	currentMap := make(map[string]bool)
	for _, t := range currentTables {
		currentMap[t] = true
	}

	desiredMap := make(map[string]bool)
	for _, t := range desiredTables {
		desiredMap[t] = true
	}

	for _, t := range desiredTables {
		if !currentMap[t] {
			toAdd = append(toAdd, t)
		}
	}

	for _, t := range currentTables {
		if !desiredMap[t] {
			toRemove = append(toRemove, t)
		}
	}

	return
}

func (r *replication) quoteIdentifier(name string) string {
	return `"` + strings.ReplaceAll(name, `"`, `""`) + `"`
}

func (r *replication) syncPublication() error {
	ctx := context.Background()
	conn := r.conn
	pubName := r.publicationName
	tableNames := r.tables

	var pubExists bool
	existsQuery := `
		SELECT EXISTS (
			SELECT 1 FROM pg_publication WHERE pubname = $1
		);
	`
	err := conn.QueryRow(ctx, existsQuery, pubName).Scan(&pubExists)
	if err != nil {
		return fmt.Errorf("failed to check publication existence: %w", err)
	}

	if !pubExists {
		tableList := make([]string, len(tableNames))
		for i, t := range tableNames {
			tableList[i] = r.quoteIdentifier(t)
		}
		createQuery := fmt.Sprintf(`CREATE PUBLICATION %s FOR TABLE %s;`,
			r.quoteIdentifier(pubName), strings.Join(tableList, ", "))

		_, err := conn.Exec(ctx, createQuery)
		if err != nil {
			return fmt.Errorf("failed to create publication: %w", err)
		}
		r.logger.Info("Successfully created publication %s with tables: [%s]", pubName, strings.Join(tableNames, ", "))
		return nil
	}

	tableQuery := `
		SELECT c.relname 
		FROM pg_publication_rel pr
		JOIN pg_class c ON pr.prrelid = c.oid
		JOIN pg_publication p ON pr.prpubid = p.oid
		WHERE p.pubname = $1
		ORDER BY c.relname;
	`
	rows, err := conn.Query(ctx, tableQuery, pubName)
	if err != nil {
		return fmt.Errorf("failed to query publication tables: %w", err)
	}
	defer rows.Close()

	var currentTables []string
	for rows.Next() {
		var tableName string
		if err := rows.Scan(&tableName); err != nil {
			return fmt.Errorf("failed to scan table name: %w", err)
		}
		currentTables = append(currentTables, tableName)
	}

	if err := rows.Err(); err != nil {
		return fmt.Errorf("failed to iterate table rows: %w", err)
	}

	sort.Strings(currentTables)
	sort.Strings(tableNames)

	isSame := true
	if len(currentTables) != len(tableNames) {
		isSame = false
	} else {
		for i := range currentTables {
			if currentTables[i] != tableNames[i] {
				isSame = false
				break
			}
		}
	}

	if !isSame {
		r.logger.Info("Publication %s table definition mismatch. Expected: %+v, Actual: %+v",
			pubName, tableNames, currentTables)

		// Get tables to add and remove
		toAdd, toRemove := r.getTableDiff(currentTables, tableNames)

		// Execute table adjustment in transaction
		tx, err := conn.Begin(ctx)
		if err != nil {
			return fmt.Errorf("failed to begin transaction: %w", err)
		}
		defer tx.Rollback(ctx)

		// Remove unwanted tables
		for _, table := range toRemove {
			removeQuery := fmt.Sprintf(`ALTER PUBLICATION %s DROP TABLE %s;`,
				r.quoteIdentifier(pubName), r.quoteIdentifier(table))
			_, err := tx.Exec(ctx, removeQuery)
			if err != nil {
				return fmt.Errorf("failed to drop table %s from publication %s: %w", table, pubName, err)
			}
			r.logger.Info("Removed table %s from publication %s", table, pubName)
		}

		for _, table := range toAdd {
			addQuery := fmt.Sprintf(`ALTER PUBLICATION %s ADD TABLE %s;`,
				r.quoteIdentifier(pubName), r.quoteIdentifier(table))
			_, err := tx.Exec(ctx, addQuery)
			if err != nil {
				return fmt.Errorf("failed to add table %s to publication %s: %w", table, pubName, err)
			}
			r.logger.Info("Added table %s to publication %s", table, pubName)
		}

		if err := tx.Commit(ctx); err != nil {
			return fmt.Errorf("failed to commit publication table adjustment transaction: %w", err)
		}

		r.logger.Info("Successfully adjusted publication %s tables. Added: [%s], Removed: [%s]",
			pubName, strings.Join(toAdd, ", "), strings.Join(toRemove, ", "))
	}

	return nil
}

func (r *replication) syncSlot() error {
	ctx := context.Background()
	var exists bool
	err := r.conn.QueryRow(ctx, `
		SELECT EXISTS(
			SELECT 1 FROM pg_replication_slots 
			WHERE slot_name = $1 AND slot_type = 'logical'
		)
	`, r.slotName).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check replication slot existence: %w", err)
	}

	if !exists {
		// Create logical replication slot
		_, err := r.conn.Exec(ctx, fmt.Sprintf(
			"SELECT pg_create_logical_replication_slot('%s', '%s')",
			r.slotName, "pgoutput",
		))
		if err != nil {
			return fmt.Errorf("failed to create replication slot: %w", err)
		}
		r.logger.Info("Successfully created replication slot: %s", r.slotName)
	} else {
		// Check if slot uses correct plugin
		var plugin string
		err := r.conn.QueryRow(ctx, `
			SELECT plugin FROM pg_replication_slots 
			WHERE slot_name = $1
		`, r.slotName).Scan(&plugin)
		if err != nil {
			return fmt.Errorf("failed to query slot plugin type: %w", err)
		}
		if plugin != "pgoutput" {
			r.logger.Error("Replication slot %s has incorrect plugin type. Expected: pgoutput, Actual: %s",
				r.slotName, plugin)
		}
	}
	return nil
}

func (r *replication) SyncAll() error {
	if err := r.syncPublication(); err != nil {
		return fmt.Errorf("failed to sync publication: %w", err)
	}
	if err := r.syncSlot(); err != nil {
		return fmt.Errorf("failed to sync replication slot: %w", err)
	}

	return nil
}

func (r *replication) Release() error {
	{
		sql := fmt.Sprintf(`DROP PUBLICATION IF EXISTS %s;`, r.publicationName)
		_, err := r.conn.Exec(context.Background(), sql)
		if err != nil {
			return err
		}
	}
	{
		sql := fmt.Sprintf("SELECT pg_drop_replication_slot('%s');", r.slotName)
		_, err := r.conn.Exec(context.Background(), sql)
		if err != nil {
			return nil
		}
	}
	return nil
}
